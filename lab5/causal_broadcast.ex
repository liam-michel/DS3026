defmodule CausalBroadcast do
    def start(name, processes) do
        spawn(CausalBroadcast, :init, [name, processes])
    end

    # Init event must be the first
    # one after the component is created
    def init(name, processes) do
        # Start the Reliable Broadcast layer
        rb = EagerReliableBroadcast.start(name, processes, self())

        # Link it with this process so they will share the
        # fate if one of them is killed
        Process.link(rb)

        # Initialise the state
        state = %{
            name: name,
            processes: processes,
            rb: rb,

            # Vector clock for delivered messages
            v: (for p <- processes, into: %{}, do: {p, 0}),

            # Current sequence number to assign to a newly broadcast message
            lsn: 0,

            # Set of pending messages
            pending: %MapSet{},
        }

        # Initialise the Tester module
        state = Tester.init(state)

        # Start the receive loop
        run(state)
    end

    def run(state) do
        state = receive do
            {:broadcast, m} ->
                # Create a vector clock w to piggybak on the message
                w = %{state.v | state.name => state.lsn}

                # Broadacst the message via Reliable Broadcast
                send(state.rb, {:broadcast, {:data, w, m}})

                # IO.puts("#{inspect state.name}: CB-broadcast: #{inspect m}")

                # Update the state
                %{state | lsn: state.lsn + 1}

            # Process a message delivered by RB
            {:rb_deliver, proc, x={:data, w, m}} ->
                # IO.puts("#{inspect state.name}: RB-deliver: #{inspect x} from #{inspect proc}")

                # Add the message to the pending buffer, and extract v from state
                {pending, v} = {MapSet.put(state.pending, {proc, w, m}), state.v}

                # Check if any pending messages can be delivered
                {pending, v} = proc_pending(MapSet.to_list(pending), v, %MapSet{})

                # Update the state
                %{state | pending: pending, v: v}

            # The next two handlers will process
            # the messages generated by the tester
            {:start_test, _} = m ->
                Tester.start_test(state, m)

            {:deliver, _, {:test, _, _}} = m ->
                Tester.proc_test_msg(state, m)

            # Default deliver
            {:deliver, proc, m} ->
                IO.puts("#{inspect state.name}: CB-deliver: #{inspect m} from #{inspect proc}")
                state

        end
        run(state)
    end

    # Returns true if v1 <= v2
    def less_or_equal(v1, v2) do
        zipped = Enum.zip(v1,v2)
        Enum.all?(
            zipped,
            fn ({x, y}) -> x <= y end
        )

    #    Compare the vectors entry-wise.
    #    Use Enum.all?

    end

    def proc_pending([], v, pending_res), do: {pending_res, v}
    def proc_pending([ {proc, w, m} | pending_tail ], v, pending_res) do

        if less_or_equal(w, v) do

            v = %{v | proc => v[proc]+1 }
            send(self(), {:deliver, proc, m})
            proc_pending(pending_tail, v, pending_res)
        else
            pending_res = MapSet.put(pending_res, {proc, w ,m})
            proc_pending(pending_tail, v, pending_res)
        end

        # if w <= v:
        #   update v
        #   trigger local delivery
        #   leave pending_res as is
        #   call proc_pending recursively with appropriate arguments
        # else:
        #   add {proc, w, m} to pending_res
        #   call proc_pending recursively with appropriate arguments
    end


    def proc_pending_reduce(pending, v) do
        # Think how to implement proc_pending using
        # Enum.reduce instead of a recursive function


    end

end
